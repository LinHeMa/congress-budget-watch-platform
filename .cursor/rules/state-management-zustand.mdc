---
globs: *.ts,*.tsx
description: 在此專案中，跨元件/全域狀態一律優先使用 Zustand；維持與現有 stores 一致的模式與檔案結構。
---

# 狀態管理準則：優先使用 Zustand

本專案規範跨元件或全域狀態管理一律優先使用 Zustand。請依下列原則實作與擴充。

- 檔案位置：將共用 store 放在 `app/stores/` 之下；可沿用現有命名慣例（例如 `uiStore.ts`、`budget-selector.tsx`）。
- 區分狀態範圍：
  - 僅影響單一元件的暫態 UI 狀態（如表單開合、hover）→ 使用 React `useState` 即可。
  - 多元件共享的 UI 狀態（如 Modal 開關、流程進度）→ 建立全域 store（如 `uiStore.ts`）。
  - 元件/小工具專屬且可多次實例化的狀態 → 使用 vanilla `createStore` 工廠模式（參考 `budget-selector.tsx`）。
- 效能與重渲染：使用 selector 取得切片狀態，例如：`useStore(store, s => s.xxx)` 或 `useUIStore(s => s.headerState)`，避免不必要重渲染。
- 開發工具：在 `process.env.NODE_ENV === 'development'` 時啟用 `devtools`，並命名好 action（方便追蹤）。
- 型別安全：為 state/action 提供完整 TypeScript 型別；避免在元件中寫入複雜匿名邏輯，盡量透過 store 的 actions 操作狀態。
- 盡量避免：以 React Context 取代 Zustand 進行全域狀態（除非為主題/國際化等極簡配置）。

---

## 樣板：全域 UI Store（devtools 與 selector）

```ts
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';

type HeaderState {
  isShareModalOpen: boolean;
}

type UIActions {
  toggleShareModal: () => void;
  openShareModal: () => void;
  closeShareModal: () => void;
}

type UIState {
  headerState: HeaderState;
  actions: UIActions;
}

export const useUIStore = create<UIState>()(
  devtools(
    (set) => ({
      headerState: { isShareModalOpen: false },
      actions: {
        toggleShareModal: () =>
          set((s) => ({ headerState: { ...s.headerState, isShareModalOpen: !s.headerState.isShareModalOpen } }), false, 'ui/toggleShareModal'),
        openShareModal: () =>
          set((s) => ({ headerState: { ...s.headerState, isShareModalOpen: true } }), false, 'ui/openShareModal'),
        closeShareModal: () =>
          set((s) => ({ headerState: { ...s.headerState, isShareModalOpen: false } }), false, 'ui/closeShareModal'),
      },
    }),
    { name: 'ui-store', enabled: process.env.NODE_ENV === 'development' }
  )
);

// 建議的 selector hooks（避免不必要重渲染）
export const useHeaderState = () => useUIStore((s) => s.headerState);
export const useUIActions = () => useUIStore((s) => s.actions);
```

---

## 樣板：可重複實例的小工具 Store（vanilla createStore）

```ts
import { createStore } from 'zustand/vanilla';

type WidgetState {
  value: string;
  visible: boolean;
  setValue: (v: string) => void;
  toggleVisible: () => void;
  reset: () => void;
}

const DEFAULTS = { value: '', visible: true } as const;

export const createWidgetStore = (init?: Partial<Pick<WidgetState, 'value' | 'visible'>>) =>
  createStore<WidgetState>()((set, get) => ({
    value: init?.value ?? DEFAULTS.value,
    visible: init?.visible ?? DEFAULTS.visible,
    setValue: (v) => set((s) => ({ ...s, value: v }), false, 'widget/setValue'),
    toggleVisible: () => set((s) => ({ ...s, visible: !s.visible }), false, 'widget/toggleVisible'),
    reset: () => set(() => ({ ...DEFAULTS }), false, 'widget/reset'),
  }));
```

使用方式（在 React 元件中）：

```ts
import { useStore } from 'zustand';

const store = createWidgetStore();
const value = useStore(store, (s) => s.value);
const setValue = useStore(store, (s) => s.setValue);
```

---

## 實作備註

- 檔案命名：沿用現有慣例（如 `uiStore.ts`、`budget-selector.tsx`）；新建全域 store 建議採 `*.store.ts` 或與現有一致。
- 事件命名：`devtools` 第三個參數提供具語意的 action 名稱（如 `module/action`）。
- 資料排序/過濾：偏資料視圖邏輯的運算（例如排序）可放在頁面層的 `useMemo`，store 僅保存選項值（如排序 key），避免在 store 內做重運算。
- SSR/動態執行：避免在 store 初始化直接操作瀏覽器 API（如 `window`）。

