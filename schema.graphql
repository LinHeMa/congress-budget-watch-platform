schema {
  query: Query
  mutation: Mutation
}

union AuthenticatedItem = User

input BooleanFilter {
  equals: Boolean
  not: BooleanFilter
}

type Budget {
  budgetAmount: Float
  budgetUrl: String
  description: String
  government: Government
  id: ID!
  lastYearSettlement: Float
  majorCategory: String
  mediumCategory: String
  minorCategory: String
  projectDescription: String
  projectName: String
  type: String
  year: Int
}

input BudgetCreateInput {
  budgetAmount: Float
  budgetUrl: String
  description: String
  government: GovernmentRelateToOneForCreateInput
  lastYearSettlement: Float
  majorCategory: String
  mediumCategory: String
  minorCategory: String
  projectDescription: String
  projectName: String
  type: String
  year: Int
}

input BudgetOrderByInput {
  budgetAmount: OrderDirection
  budgetUrl: OrderDirection
  description: OrderDirection
  id: OrderDirection
  lastYearSettlement: OrderDirection
  majorCategory: OrderDirection
  mediumCategory: OrderDirection
  minorCategory: OrderDirection
  projectDescription: OrderDirection
  projectName: OrderDirection
  type: OrderDirection
  year: OrderDirection
}

input BudgetRelateToOneForCreateInput {
  connect: BudgetWhereUniqueInput
  create: BudgetCreateInput
}

input BudgetRelateToOneForUpdateInput {
  connect: BudgetWhereUniqueInput
  create: BudgetCreateInput
  disconnect: Boolean
}

input BudgetUpdateArgs {
  data: BudgetUpdateInput!
  where: BudgetWhereUniqueInput!
}

input BudgetUpdateInput {
  budgetAmount: Float
  budgetUrl: String
  description: String
  government: GovernmentRelateToOneForUpdateInput
  lastYearSettlement: Float
  majorCategory: String
  mediumCategory: String
  minorCategory: String
  projectDescription: String
  projectName: String
  type: String
  year: Int
}

input BudgetWhereInput {
  AND: [BudgetWhereInput!]
  NOT: [BudgetWhereInput!]
  OR: [BudgetWhereInput!]
  budgetAmount: FloatFilter
  budgetUrl: StringNullableFilter
  description: StringNullableFilter
  government: GovernmentWhereInput
  id: IDFilter
  lastYearSettlement: FloatNullableFilter
  majorCategory: StringFilter
  mediumCategory: StringFilter
  minorCategory: StringFilter
  projectDescription: StringNullableFilter
  projectName: StringNullableFilter
  type: StringFilter
  year: IntFilter
}

input BudgetWhereUniqueInput {
  id: ID
}

type Committee {
  description: String
  displayName: String
  endDate: DateTime
  id: ID!
  key: String
  members(cursor: PeopleWhereUniqueInput, orderBy: [PeopleOrderByInput!]! = [], skip: Int! = 0, take: Int, where: PeopleWhereInput! = {}): [People!]
  membersCount(where: PeopleWhereInput! = {}): Int
  name: String
  session: String
  startDate: DateTime
  term: Term
}

input CommitteeCreateInput {
  description: String
  endDate: DateTime
  members: PeopleRelateToManyForCreateInput
  name: String
  session: String
  startDate: DateTime
  term: TermRelateToOneForCreateInput
}

input CommitteeManyRelationFilter {
  every: CommitteeWhereInput
  none: CommitteeWhereInput
  some: CommitteeWhereInput
}

input CommitteeOrderByInput {
  description: OrderDirection
  endDate: OrderDirection
  id: OrderDirection
  name: OrderDirection
  session: OrderDirection
  startDate: OrderDirection
}

input CommitteeRelateToManyForCreateInput {
  connect: [CommitteeWhereUniqueInput!]
  create: [CommitteeCreateInput!]
}

input CommitteeRelateToManyForUpdateInput {
  connect: [CommitteeWhereUniqueInput!]
  create: [CommitteeCreateInput!]
  disconnect: [CommitteeWhereUniqueInput!]
  set: [CommitteeWhereUniqueInput!]
}

input CommitteeRelateToOneForCreateInput {
  connect: CommitteeWhereUniqueInput
  create: CommitteeCreateInput
}

input CommitteeRelateToOneForUpdateInput {
  connect: CommitteeWhereUniqueInput
  create: CommitteeCreateInput
  disconnect: Boolean
}

input CommitteeUpdateArgs {
  data: CommitteeUpdateInput!
  where: CommitteeWhereUniqueInput!
}

input CommitteeUpdateInput {
  description: String
  endDate: DateTime
  members: PeopleRelateToManyForUpdateInput
  name: String
  session: String
  startDate: DateTime
  term: TermRelateToOneForUpdateInput
}

input CommitteeWhereInput {
  AND: [CommitteeWhereInput!]
  NOT: [CommitteeWhereInput!]
  OR: [CommitteeWhereInput!]
  description: StringNullableFilter
  endDate: DateTimeNullableFilter
  id: IDFilter
  members: PeopleManyRelationFilter
  name: StringFilter
  session: StringFilter
  startDate: DateTimeFilter
  term: TermWhereInput
}

input CommitteeWhereUniqueInput {
  id: ID
}

input CreateInitialUserInput {
  email: String
  name: String
  password: String
  role: String
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: DateTimeNullableFilter
  notIn: [DateTime!]
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: FloatFilter
  notIn: [Float!]
}

input FloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: FloatNullableFilter
  notIn: [Float!]
}

type Government {
  category: String
  description: String
  id: ID!
  name: String
}

input GovernmentCreateInput {
  category: String
  description: String
  name: String
}

input GovernmentOrderByInput {
  category: OrderDirection
  description: OrderDirection
  id: OrderDirection
  name: OrderDirection
}

input GovernmentRelateToOneForCreateInput {
  connect: GovernmentWhereUniqueInput
  create: GovernmentCreateInput
}

input GovernmentRelateToOneForUpdateInput {
  connect: GovernmentWhereUniqueInput
  create: GovernmentCreateInput
  disconnect: Boolean
}

input GovernmentUpdateArgs {
  data: GovernmentUpdateInput!
  where: GovernmentWhereUniqueInput!
}

input GovernmentUpdateInput {
  category: String
  description: String
  name: String
}

input GovernmentWhereInput {
  AND: [GovernmentWhereInput!]
  NOT: [GovernmentWhereInput!]
  OR: [GovernmentWhereInput!]
  category: StringFilter
  description: StringNullableFilter
  id: IDFilter
  name: StringFilter
}

input GovernmentWhereUniqueInput {
  id: ID
}

input IDFilter {
  equals: ID
  gt: ID
  gte: ID
  in: [ID!]
  lt: ID
  lte: ID
  not: IDFilter
  notIn: [ID!]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: IntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: IntNullableFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type KeystoneAdminMeta {
  list(key: String!): KeystoneAdminUIListMeta
  lists: [KeystoneAdminUIListMeta!]!
}

type KeystoneAdminUIFieldGroupMeta {
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
  label: String!
}

type KeystoneAdminUIFieldMeta {
  createView: KeystoneAdminUIFieldMetaCreateView!
  customViewsIndex: Int
  description: String
  fieldMeta: JSON
  isFilterable: Boolean!
  isNonNull: [KeystoneAdminUIFieldMetaIsNonNull!]
  isOrderable: Boolean!
  itemView(id: ID): KeystoneAdminUIFieldMetaItemView
  label: String!
  listView: KeystoneAdminUIFieldMetaListView!
  path: String!
  search: QueryMode
  viewsIndex: Int!
}

type KeystoneAdminUIFieldMetaCreateView {
  fieldMode: KeystoneAdminUIFieldMetaCreateViewFieldMode!
}

enum KeystoneAdminUIFieldMetaCreateViewFieldMode {
  edit
  hidden
}

enum KeystoneAdminUIFieldMetaIsNonNull {
  create
  read
  update
}

type KeystoneAdminUIFieldMetaItemView {
  fieldMode: KeystoneAdminUIFieldMetaItemViewFieldMode
  fieldPosition: KeystoneAdminUIFieldMetaItemViewFieldPosition
}

enum KeystoneAdminUIFieldMetaItemViewFieldMode {
  edit
  hidden
  read
}

enum KeystoneAdminUIFieldMetaItemViewFieldPosition {
  form
  sidebar
}

type KeystoneAdminUIFieldMetaListView {
  fieldMode: KeystoneAdminUIFieldMetaListViewFieldMode!
}

enum KeystoneAdminUIFieldMetaListViewFieldMode {
  hidden
  read
}

type KeystoneAdminUIListMeta {
  description: String
  fields: [KeystoneAdminUIFieldMeta!]!
  groups: [KeystoneAdminUIFieldGroupMeta!]!
  hideCreate: Boolean!
  hideDelete: Boolean!
  initialColumns: [String!]!
  initialSort: KeystoneAdminUISort
  isHidden: Boolean!
  isSingleton: Boolean!
  itemQueryName: String!
  key: String!
  label: String!
  labelField: String!
  listQueryName: String!
  pageSize: Int!
  path: String!
  plural: String!
  singular: String!
}

type KeystoneAdminUISort {
  direction: KeystoneAdminUISortDirection!
  field: String!
}

enum KeystoneAdminUISortDirection {
  ASC
  DESC
}

type KeystoneMeta {
  adminMeta: KeystoneAdminMeta!
}

type Meeting {
  committee: Committee
  description: String
  displayName: String
  government: Government
  id: ID!
  location: String
  meetingDate: DateTime
  meetingRecordUrl: String
  type: String
}

input MeetingCreateInput {
  committee: CommitteeRelateToOneForCreateInput
  description: String
  government: GovernmentRelateToOneForCreateInput
  location: String
  meetingDate: DateTime
  meetingRecordUrl: String
  type: String
}

input MeetingManyRelationFilter {
  every: MeetingWhereInput
  none: MeetingWhereInput
  some: MeetingWhereInput
}

input MeetingOrderByInput {
  description: OrderDirection
  id: OrderDirection
  location: OrderDirection
  meetingDate: OrderDirection
  meetingRecordUrl: OrderDirection
  type: OrderDirection
}

input MeetingRelateToManyForCreateInput {
  connect: [MeetingWhereUniqueInput!]
  create: [MeetingCreateInput!]
}

input MeetingRelateToManyForUpdateInput {
  connect: [MeetingWhereUniqueInput!]
  create: [MeetingCreateInput!]
  disconnect: [MeetingWhereUniqueInput!]
  set: [MeetingWhereUniqueInput!]
}

input MeetingRelateToOneForCreateInput {
  connect: MeetingWhereUniqueInput
  create: MeetingCreateInput
}

input MeetingRelateToOneForUpdateInput {
  connect: MeetingWhereUniqueInput
  create: MeetingCreateInput
  disconnect: Boolean
}

input MeetingUpdateArgs {
  data: MeetingUpdateInput!
  where: MeetingWhereUniqueInput!
}

input MeetingUpdateInput {
  committee: CommitteeRelateToOneForUpdateInput
  description: String
  government: GovernmentRelateToOneForUpdateInput
  location: String
  meetingDate: DateTime
  meetingRecordUrl: String
  type: String
}

input MeetingWhereInput {
  AND: [MeetingWhereInput!]
  NOT: [MeetingWhereInput!]
  OR: [MeetingWhereInput!]
  committee: CommitteeWhereInput
  description: StringFilter
  government: GovernmentWhereInput
  id: IDFilter
  location: StringNullableFilter
  meetingDate: DateTimeNullableFilter
  meetingRecordUrl: StringFilter
  type: StringNullableFilter
}

input MeetingWhereUniqueInput {
  id: ID
}

type Mutation {
  authenticateUserWithPassword(email: String!, password: String!): UserAuthenticationWithPasswordResult
  createBudget(data: BudgetCreateInput!): Budget
  createBudgets(data: [BudgetCreateInput!]!): [Budget]
  createCommittee(data: CommitteeCreateInput!): Committee
  createCommittees(data: [CommitteeCreateInput!]!): [Committee]
  createGovernment(data: GovernmentCreateInput!): Government
  createGovernments(data: [GovernmentCreateInput!]!): [Government]
  createInitialUser(data: CreateInitialUserInput!): UserAuthenticationWithPasswordSuccess!
  createMeeting(data: MeetingCreateInput!): Meeting
  createMeetings(data: [MeetingCreateInput!]!): [Meeting]
  createParties(data: [PartyCreateInput!]!): [Party]
  createParty(data: PartyCreateInput!): Party
  createPeople(data: PeopleCreateInput!): People
  createPeopleList(data: [PeopleCreateInput!]!): [People]
  createProposal(data: ProposalCreateInput!): Proposal
  createProposals(data: [ProposalCreateInput!]!): [Proposal]
  createRecognitionImage(data: RecognitionImageCreateInput!): RecognitionImage
  createRecognitionImages(data: [RecognitionImageCreateInput!]!): [RecognitionImage]
  createRecognitionStatus(data: RecognitionStatusCreateInput!): RecognitionStatus
  createRecognitionStatuses(data: [RecognitionStatusCreateInput!]!): [RecognitionStatus]
  createTerm(data: TermCreateInput!): Term
  createTerms(data: [TermCreateInput!]!): [Term]
  createUser(data: UserCreateInput!): User
  createUsers(data: [UserCreateInput!]!): [User]
  deleteBudget(where: BudgetWhereUniqueInput!): Budget
  deleteBudgets(where: [BudgetWhereUniqueInput!]!): [Budget]
  deleteCommittee(where: CommitteeWhereUniqueInput!): Committee
  deleteCommittees(where: [CommitteeWhereUniqueInput!]!): [Committee]
  deleteGovernment(where: GovernmentWhereUniqueInput!): Government
  deleteGovernments(where: [GovernmentWhereUniqueInput!]!): [Government]
  deleteMeeting(where: MeetingWhereUniqueInput!): Meeting
  deleteMeetings(where: [MeetingWhereUniqueInput!]!): [Meeting]
  deleteParties(where: [PartyWhereUniqueInput!]!): [Party]
  deleteParty(where: PartyWhereUniqueInput!): Party
  deletePeople(where: PeopleWhereUniqueInput!): People
  deletePeopleList(where: [PeopleWhereUniqueInput!]!): [People]
  deleteProposal(where: ProposalWhereUniqueInput!): Proposal
  deleteProposals(where: [ProposalWhereUniqueInput!]!): [Proposal]
  deleteRecognitionImage(where: RecognitionImageWhereUniqueInput!): RecognitionImage
  deleteRecognitionImages(where: [RecognitionImageWhereUniqueInput!]!): [RecognitionImage]
  deleteRecognitionStatus(where: RecognitionStatusWhereUniqueInput!): RecognitionStatus
  deleteRecognitionStatuses(where: [RecognitionStatusWhereUniqueInput!]!): [RecognitionStatus]
  deleteTerm(where: TermWhereUniqueInput!): Term
  deleteTerms(where: [TermWhereUniqueInput!]!): [Term]
  deleteUser(where: UserWhereUniqueInput!): User
  deleteUsers(where: [UserWhereUniqueInput!]!): [User]
  endSession: Boolean!
  updateBudget(data: BudgetUpdateInput!, where: BudgetWhereUniqueInput!): Budget
  updateBudgets(data: [BudgetUpdateArgs!]!): [Budget]
  updateCommittee(data: CommitteeUpdateInput!, where: CommitteeWhereUniqueInput!): Committee
  updateCommittees(data: [CommitteeUpdateArgs!]!): [Committee]
  updateGovernment(data: GovernmentUpdateInput!, where: GovernmentWhereUniqueInput!): Government
  updateGovernments(data: [GovernmentUpdateArgs!]!): [Government]
  updateMeeting(data: MeetingUpdateInput!, where: MeetingWhereUniqueInput!): Meeting
  updateMeetings(data: [MeetingUpdateArgs!]!): [Meeting]
  updateParties(data: [PartyUpdateArgs!]!): [Party]
  updateParty(data: PartyUpdateInput!, where: PartyWhereUniqueInput!): Party
  updatePeople(data: PeopleUpdateInput!, where: PeopleWhereUniqueInput!): People
  updatePeopleList(data: [PeopleUpdateArgs!]!): [People]
  updateProposal(data: ProposalUpdateInput!, where: ProposalWhereUniqueInput!): Proposal
  updateProposals(data: [ProposalUpdateArgs!]!): [Proposal]
  updateRecognitionImage(data: RecognitionImageUpdateInput!, where: RecognitionImageWhereUniqueInput!): RecognitionImage
  updateRecognitionImages(data: [RecognitionImageUpdateArgs!]!): [RecognitionImage]
  updateRecognitionStatus(data: RecognitionStatusUpdateInput!, where: RecognitionStatusWhereUniqueInput!): RecognitionStatus
  updateRecognitionStatuses(data: [RecognitionStatusUpdateArgs!]!): [RecognitionStatus]
  updateTerm(data: TermUpdateInput!, where: TermWhereUniqueInput!): Term
  updateTerms(data: [TermUpdateArgs!]!): [Term]
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateUsers(data: [UserUpdateArgs!]!): [User]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

enum OrderDirection {
  asc
  desc
}

type Party {
  id: ID!
  name: String
}

input PartyCreateInput {
  name: String
}

input PartyOrderByInput {
  id: OrderDirection
  name: OrderDirection
}

input PartyRelateToOneForCreateInput {
  connect: PartyWhereUniqueInput
  create: PartyCreateInput
}

input PartyRelateToOneForUpdateInput {
  connect: PartyWhereUniqueInput
  create: PartyCreateInput
  disconnect: Boolean
}

input PartyUpdateArgs {
  data: PartyUpdateInput!
  where: PartyWhereUniqueInput!
}

input PartyUpdateInput {
  name: String
}

input PartyWhereInput {
  AND: [PartyWhereInput!]
  NOT: [PartyWhereInput!]
  OR: [PartyWhereInput!]
  id: IDFilter
  name: StringFilter
}

input PartyWhereUniqueInput {
  id: ID
  name: String
}

type PasswordState {
  isSet: Boolean!
}

type People {
  committees(cursor: CommitteeWhereUniqueInput, orderBy: [CommitteeOrderByInput!]! = [], skip: Int! = 0, take: Int, where: CommitteeWhereInput! = {}): [Committee!]
  committeesCount(where: CommitteeWhereInput! = {}): Int
  description: String
  id: ID!
  name: String
  party: Party
  term: Term
  type: String
}

input PeopleCreateInput {
  committees: CommitteeRelateToManyForCreateInput
  description: String
  name: String
  party: PartyRelateToOneForCreateInput
  term: TermRelateToOneForCreateInput
  type: String
}

input PeopleManyRelationFilter {
  every: PeopleWhereInput
  none: PeopleWhereInput
  some: PeopleWhereInput
}

input PeopleOrderByInput {
  description: OrderDirection
  id: OrderDirection
  name: OrderDirection
  type: OrderDirection
}

input PeopleRelateToManyForCreateInput {
  connect: [PeopleWhereUniqueInput!]
  create: [PeopleCreateInput!]
}

input PeopleRelateToManyForUpdateInput {
  connect: [PeopleWhereUniqueInput!]
  create: [PeopleCreateInput!]
  disconnect: [PeopleWhereUniqueInput!]
  set: [PeopleWhereUniqueInput!]
}

input PeopleUpdateArgs {
  data: PeopleUpdateInput!
  where: PeopleWhereUniqueInput!
}

input PeopleUpdateInput {
  committees: CommitteeRelateToManyForUpdateInput
  description: String
  name: String
  party: PartyRelateToOneForUpdateInput
  term: TermRelateToOneForUpdateInput
  type: String
}

input PeopleWhereInput {
  AND: [PeopleWhereInput!]
  NOT: [PeopleWhereInput!]
  OR: [PeopleWhereInput!]
  committees: CommitteeManyRelationFilter
  description: StringFilter
  id: IDFilter
  name: StringFilter
  party: PartyWhereInput
  term: TermWhereInput
  type: StringFilter
}

input PeopleWhereUniqueInput {
  id: ID
}

type Proposal {
  budget: Budget
  budgetImageUrl: String
  coSigners(cursor: PeopleWhereUniqueInput, orderBy: [PeopleOrderByInput!]! = [], skip: Int! = 0, take: Int, where: PeopleWhereInput! = {}): [People!]
  coSignersCount(where: PeopleWhereInput! = {}): Int
  description: String
  freezeAmount: Int
  government: Government
  historicalProposals(cursor: ProposalWhereUniqueInput, orderBy: [ProposalOrderByInput!]! = [], skip: Int! = 0, take: Int, where: ProposalWhereInput! = {}): [Proposal!]
  historicalProposalsCount(where: ProposalWhereInput! = {}): Int
  id: ID!
  meetings(cursor: MeetingWhereUniqueInput, orderBy: [MeetingOrderByInput!]! = [], skip: Int! = 0, take: Int, where: MeetingWhereInput! = {}): [Meeting!]
  meetingsCount(where: MeetingWhereInput! = {}): Int
  mergedProposals(cursor: ProposalWhereUniqueInput, orderBy: [ProposalOrderByInput!]! = [], skip: Int! = 0, take: Int, where: ProposalWhereInput! = {}): [Proposal!]
  mergedProposalsCount(where: ProposalWhereInput! = {}): Int
  proposalTypes: [ProposalProposalTypeType!]
  proposers(cursor: PeopleWhereUniqueInput, orderBy: [PeopleOrderByInput!]! = [], skip: Int! = 0, take: Int, where: PeopleWhereInput! = {}): [People!]
  proposersCount(where: PeopleWhereInput! = {}): Int
  publishStatus: String
  react_angry: Int
  react_disappoint: Int
  react_good: Int
  react_whatever: Int
  reason: String
  recognitionAnswer: String
  reductionAmount: Int
  result: String
  unfreezeHistory(cursor: MeetingWhereUniqueInput, orderBy: [MeetingOrderByInput!]! = [], skip: Int! = 0, take: Int, where: MeetingWhereInput! = {}): [Meeting!]
  unfreezeHistoryCount(where: MeetingWhereInput! = {}): Int
  unfreezeStatus: String
}

input ProposalCreateInput {
  budget: BudgetRelateToOneForCreateInput
  budgetImageUrl: String
  coSigners: PeopleRelateToManyForCreateInput
  description: String
  freezeAmount: Int
  government: GovernmentRelateToOneForCreateInput
  historicalProposals: ProposalRelateToManyForCreateInput
  meetings: MeetingRelateToManyForCreateInput
  mergedProposals: ProposalRelateToManyForCreateInput
  proposalTypes: [ProposalProposalTypeType!]
  proposers: PeopleRelateToManyForCreateInput
  publishStatus: String
  react_angry: Int
  react_disappoint: Int
  react_good: Int
  react_whatever: Int
  reason: String
  recognitionAnswer: String
  reductionAmount: Int
  result: String
  unfreezeHistory: MeetingRelateToManyForCreateInput
  unfreezeStatus: String
}

input ProposalManyRelationFilter {
  every: ProposalWhereInput
  none: ProposalWhereInput
  some: ProposalWhereInput
}

input ProposalOrderByInput {
  budgetImageUrl: OrderDirection
  description: OrderDirection
  freezeAmount: OrderDirection
  id: OrderDirection
  publishStatus: OrderDirection
  react_angry: OrderDirection
  react_disappoint: OrderDirection
  react_good: OrderDirection
  react_whatever: OrderDirection
  reason: OrderDirection
  recognitionAnswer: OrderDirection
  reductionAmount: OrderDirection
  result: OrderDirection
  unfreezeStatus: OrderDirection
}

enum ProposalProposalTypeType {
  freeze
  other
  reduce
}

input ProposalRelateToManyForCreateInput {
  connect: [ProposalWhereUniqueInput!]
  create: [ProposalCreateInput!]
}

input ProposalRelateToManyForUpdateInput {
  connect: [ProposalWhereUniqueInput!]
  create: [ProposalCreateInput!]
  disconnect: [ProposalWhereUniqueInput!]
  set: [ProposalWhereUniqueInput!]
}

input ProposalUpdateArgs {
  data: ProposalUpdateInput!
  where: ProposalWhereUniqueInput!
}

input ProposalUpdateInput {
  budget: BudgetRelateToOneForUpdateInput
  budgetImageUrl: String
  coSigners: PeopleRelateToManyForUpdateInput
  description: String
  freezeAmount: Int
  government: GovernmentRelateToOneForUpdateInput
  historicalProposals: ProposalRelateToManyForUpdateInput
  meetings: MeetingRelateToManyForUpdateInput
  mergedProposals: ProposalRelateToManyForUpdateInput
  proposalTypes: [ProposalProposalTypeType!]
  proposers: PeopleRelateToManyForUpdateInput
  publishStatus: String
  react_angry: Int
  react_disappoint: Int
  react_good: Int
  react_whatever: Int
  reason: String
  recognitionAnswer: String
  reductionAmount: Int
  result: String
  unfreezeHistory: MeetingRelateToManyForUpdateInput
  unfreezeStatus: String
}

input ProposalWhereInput {
  AND: [ProposalWhereInput!]
  NOT: [ProposalWhereInput!]
  OR: [ProposalWhereInput!]
  budget: BudgetWhereInput
  budgetImageUrl: StringNullableFilter
  coSigners: PeopleManyRelationFilter
  description: StringNullableFilter
  freezeAmount: IntNullableFilter
  government: GovernmentWhereInput
  historicalProposals: ProposalManyRelationFilter
  id: IDFilter
  meetings: MeetingManyRelationFilter
  mergedProposals: ProposalManyRelationFilter
  proposers: PeopleManyRelationFilter
  publishStatus: StringNullableFilter
  react_angry: IntNullableFilter
  react_disappoint: IntNullableFilter
  react_good: IntNullableFilter
  react_whatever: IntNullableFilter
  reason: StringNullableFilter
  recognitionAnswer: StringNullableFilter
  reductionAmount: IntNullableFilter
  result: StringNullableFilter
  unfreezeHistory: MeetingManyRelationFilter
  unfreezeStatus: StringNullableFilter
}

input ProposalWhereUniqueInput {
  id: ID
}

type Query {
  authenticatedItem: AuthenticatedItem
  budget(where: BudgetWhereUniqueInput!): Budget
  budgets(cursor: BudgetWhereUniqueInput, orderBy: [BudgetOrderByInput!]! = [], skip: Int! = 0, take: Int, where: BudgetWhereInput! = {}): [Budget!]
  budgetsCount(where: BudgetWhereInput! = {}): Int
  committee(where: CommitteeWhereUniqueInput!): Committee
  committees(cursor: CommitteeWhereUniqueInput, orderBy: [CommitteeOrderByInput!]! = [], skip: Int! = 0, take: Int, where: CommitteeWhereInput! = {}): [Committee!]
  committeesCount(where: CommitteeWhereInput! = {}): Int
  government(where: GovernmentWhereUniqueInput!): Government
  governments(cursor: GovernmentWhereUniqueInput, orderBy: [GovernmentOrderByInput!]! = [], skip: Int! = 0, take: Int, where: GovernmentWhereInput! = {}): [Government!]
  governmentsCount(where: GovernmentWhereInput! = {}): Int
  keystone: KeystoneMeta!
  meeting(where: MeetingWhereUniqueInput!): Meeting
  meetings(cursor: MeetingWhereUniqueInput, orderBy: [MeetingOrderByInput!]! = [], skip: Int! = 0, take: Int, where: MeetingWhereInput! = {}): [Meeting!]
  meetingsCount(where: MeetingWhereInput! = {}): Int
  parties(cursor: PartyWhereUniqueInput, orderBy: [PartyOrderByInput!]! = [], skip: Int! = 0, take: Int, where: PartyWhereInput! = {}): [Party!]
  partiesCount(where: PartyWhereInput! = {}): Int
  party(where: PartyWhereUniqueInput!): Party
  people(where: PeopleWhereUniqueInput!): People
  peopleList(cursor: PeopleWhereUniqueInput, orderBy: [PeopleOrderByInput!]! = [], skip: Int! = 0, take: Int, where: PeopleWhereInput! = {}): [People!]
  peopleListCount(where: PeopleWhereInput! = {}): Int
  proposal(where: ProposalWhereUniqueInput!): Proposal
  proposals(cursor: ProposalWhereUniqueInput, orderBy: [ProposalOrderByInput!]! = [], skip: Int! = 0, take: Int, where: ProposalWhereInput! = {}): [Proposal!]
  proposalsCount(where: ProposalWhereInput! = {}): Int
  recognitionImage(where: RecognitionImageWhereUniqueInput!): RecognitionImage
  recognitionImages(cursor: RecognitionImageWhereUniqueInput, orderBy: [RecognitionImageOrderByInput!]! = [], skip: Int! = 0, take: Int, where: RecognitionImageWhereInput! = {}): [RecognitionImage!]
  recognitionImagesCount(where: RecognitionImageWhereInput! = {}): Int
  recognitionStatus(where: RecognitionStatusWhereUniqueInput!): RecognitionStatus
  recognitionStatuses(cursor: RecognitionStatusWhereUniqueInput, orderBy: [RecognitionStatusOrderByInput!]! = [], skip: Int! = 0, take: Int, where: RecognitionStatusWhereInput! = {}): [RecognitionStatus!]
  recognitionStatusesCount(where: RecognitionStatusWhereInput! = {}): Int
  term(where: TermWhereUniqueInput!): Term
  terms(cursor: TermWhereUniqueInput, orderBy: [TermOrderByInput!]! = [], skip: Int! = 0, take: Int, where: TermWhereInput! = {}): [Term!]
  termsCount(where: TermWhereInput! = {}): Int
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, orderBy: [UserOrderByInput!]! = [], skip: Int! = 0, take: Int, where: UserWhereInput! = {}): [User!]
  usersCount(where: UserWhereInput! = {}): Int
}

enum QueryMode {
  default
  insensitive
}

type RecognitionImage {
  description: String
  government: Government
  historicalProposals(cursor: ProposalWhereUniqueInput, orderBy: [ProposalOrderByInput!]! = [], skip: Int! = 0, take: Int, where: ProposalWhereInput! = {}): [Proposal!]
  historicalProposalsCount(where: ProposalWhereInput! = {}): Int
  id: ID!
  imageUrl: String
  meeting: Meeting
  mergedProposals(cursor: ProposalWhereUniqueInput, orderBy: [ProposalOrderByInput!]! = [], skip: Int! = 0, take: Int, where: ProposalWhereInput! = {}): [Proposal!]
  mergedProposalsCount(where: ProposalWhereInput! = {}): Int
  pageNumber: Int
  result: String
  verificationStatus: String
}

input RecognitionImageCreateInput {
  description: String
  government: GovernmentRelateToOneForCreateInput
  historicalProposals: ProposalRelateToManyForCreateInput
  imageUrl: String
  meeting: MeetingRelateToOneForCreateInput
  mergedProposals: ProposalRelateToManyForCreateInput
  pageNumber: Int
  result: String
  verificationStatus: String
}

input RecognitionImageOrderByInput {
  description: OrderDirection
  id: OrderDirection
  imageUrl: OrderDirection
  pageNumber: OrderDirection
  result: OrderDirection
  verificationStatus: OrderDirection
}

input RecognitionImageRelateToOneForCreateInput {
  connect: RecognitionImageWhereUniqueInput
  create: RecognitionImageCreateInput
}

input RecognitionImageRelateToOneForUpdateInput {
  connect: RecognitionImageWhereUniqueInput
  create: RecognitionImageCreateInput
  disconnect: Boolean
}

input RecognitionImageUpdateArgs {
  data: RecognitionImageUpdateInput!
  where: RecognitionImageWhereUniqueInput!
}

input RecognitionImageUpdateInput {
  description: String
  government: GovernmentRelateToOneForUpdateInput
  historicalProposals: ProposalRelateToManyForUpdateInput
  imageUrl: String
  meeting: MeetingRelateToOneForUpdateInput
  mergedProposals: ProposalRelateToManyForUpdateInput
  pageNumber: Int
  result: String
  verificationStatus: String
}

input RecognitionImageWhereInput {
  AND: [RecognitionImageWhereInput!]
  NOT: [RecognitionImageWhereInput!]
  OR: [RecognitionImageWhereInput!]
  description: StringNullableFilter
  government: GovernmentWhereInput
  historicalProposals: ProposalManyRelationFilter
  id: IDFilter
  imageUrl: StringFilter
  meeting: MeetingWhereInput
  mergedProposals: ProposalManyRelationFilter
  pageNumber: IntNullableFilter
  result: StringNullableFilter
  verificationStatus: StringNullableFilter
}

input RecognitionImageWhereUniqueInput {
  id: ID
}

type RecognitionStatus {
  budgetAmountResult: String
  budgetCategoryResult: String
  budgetTypeResult: String
  coSigners: String
  description: String
  freezeAmountResult: String
  governmentBudgetResult: String
  id: ID!
  image: RecognitionImage
  lineuserid: String
  proposers: String
  reason: String
  reductionAmountResult: String
  type: String
}

input RecognitionStatusCreateInput {
  budgetAmountResult: String
  budgetCategoryResult: String
  budgetTypeResult: String
  coSigners: String
  description: String
  freezeAmountResult: String
  governmentBudgetResult: String
  image: RecognitionImageRelateToOneForCreateInput
  lineuserid: String
  proposers: String
  reason: String
  reductionAmountResult: String
  type: String
}

input RecognitionStatusOrderByInput {
  budgetAmountResult: OrderDirection
  budgetCategoryResult: OrderDirection
  budgetTypeResult: OrderDirection
  coSigners: OrderDirection
  description: OrderDirection
  freezeAmountResult: OrderDirection
  governmentBudgetResult: OrderDirection
  id: OrderDirection
  lineuserid: OrderDirection
  proposers: OrderDirection
  reason: OrderDirection
  reductionAmountResult: OrderDirection
  type: OrderDirection
}

input RecognitionStatusUpdateArgs {
  data: RecognitionStatusUpdateInput!
  where: RecognitionStatusWhereUniqueInput!
}

input RecognitionStatusUpdateInput {
  budgetAmountResult: String
  budgetCategoryResult: String
  budgetTypeResult: String
  coSigners: String
  description: String
  freezeAmountResult: String
  governmentBudgetResult: String
  image: RecognitionImageRelateToOneForUpdateInput
  lineuserid: String
  proposers: String
  reason: String
  reductionAmountResult: String
  type: String
}

input RecognitionStatusWhereInput {
  AND: [RecognitionStatusWhereInput!]
  NOT: [RecognitionStatusWhereInput!]
  OR: [RecognitionStatusWhereInput!]
  budgetAmountResult: StringNullableFilter
  budgetCategoryResult: StringNullableFilter
  budgetTypeResult: StringNullableFilter
  coSigners: StringNullableFilter
  description: StringNullableFilter
  freezeAmountResult: StringNullableFilter
  governmentBudgetResult: StringNullableFilter
  id: IDFilter
  image: RecognitionImageWhereInput
  lineuserid: StringNullableFilter
  proposers: StringNullableFilter
  reason: StringNullableFilter
  reductionAmountResult: StringNullableFilter
  type: StringFilter
}

input RecognitionStatusWhereUniqueInput {
  id: ID
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Term {
  description: String
  endDate: DateTime
  id: ID!
  startDate: DateTime
  termNumber: Int
}

input TermCreateInput {
  description: String
  endDate: DateTime
  startDate: DateTime
  termNumber: Int
}

input TermOrderByInput {
  description: OrderDirection
  endDate: OrderDirection
  id: OrderDirection
  startDate: OrderDirection
  termNumber: OrderDirection
}

input TermRelateToOneForCreateInput {
  connect: TermWhereUniqueInput
  create: TermCreateInput
}

input TermRelateToOneForUpdateInput {
  connect: TermWhereUniqueInput
  create: TermCreateInput
  disconnect: Boolean
}

input TermUpdateArgs {
  data: TermUpdateInput!
  where: TermWhereUniqueInput!
}

input TermUpdateInput {
  description: String
  endDate: DateTime
  startDate: DateTime
  termNumber: Int
}

input TermWhereInput {
  AND: [TermWhereInput!]
  NOT: [TermWhereInput!]
  OR: [TermWhereInput!]
  description: StringNullableFilter
  endDate: DateTimeNullableFilter
  id: IDFilter
  startDate: DateTimeFilter
  termNumber: IntFilter
}

input TermWhereUniqueInput {
  id: ID
  termNumber: Int
}

type User {
  email: String
  id: ID!
  isProtected: Boolean
  name: String
  password: PasswordState
  role: String
}

type UserAuthenticationWithPasswordFailure {
  message: String!
}

union UserAuthenticationWithPasswordResult = UserAuthenticationWithPasswordFailure | UserAuthenticationWithPasswordSuccess

type UserAuthenticationWithPasswordSuccess {
  item: User!
  sessionToken: String!
}

input UserCreateInput {
  email: String
  isProtected: Boolean
  name: String
  password: String
  role: String
}

input UserOrderByInput {
  email: OrderDirection
  id: OrderDirection
  isProtected: OrderDirection
  name: OrderDirection
  role: OrderDirection
}

input UserUpdateArgs {
  data: UserUpdateInput!
  where: UserWhereUniqueInput!
}

input UserUpdateInput {
  email: String
  isProtected: Boolean
  name: String
  password: String
  role: String
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringFilter
  id: IDFilter
  isProtected: BooleanFilter
  name: StringFilter
  role: StringFilter
}

input UserWhereUniqueInput {
  email: String
  id: ID
}